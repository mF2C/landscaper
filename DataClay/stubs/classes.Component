# dataClay header
# This is a Stub, to be used for the user client
from dataclay import dclayMethod, DataClayObject

# Imports required by the following class

# Definition of dataClay object class: Component
class Component(DataClayObject):

    @dclayMethod(obj='anything', property_name='str', value='anything', beforeUpdate='str', afterUpdate='str')
    def __setUpdate__(self, obj, property_name, value, beforeUpdate, afterUpdate):
        if beforeUpdate is not None:
            getattr(self, beforeUpdate)(property_name, value)
        object.__setattr__(obj, "%s%s" % ("_dataclay_property_", property_name), value)
        if afterUpdate is not None:
            getattr(self, afterUpdate)(property_name, value)
    @dclayMethod(sensor_type="str", actuator_type="str", comm_info="str", device_type="str", location="str")
    def __init__(self, sensor_type, actuator_type, comm_info, device_type, location):
        self.sensor_type = sensor_type
        self.actuator_type = actuator_type
        self.communication_info = comm_info
        self.device_type = device_type
        self.location = location
    @dclayMethod(other="model_mf2c.classes.Component", return_="bool")
    def __eq__(self, other):
        if not isinstance(other, Component):
            return False

        return all((
            self.sensor_type == other.sensor_type,
            self.actuator_type == other.actuator_type,
            self.communication_info == other.communication_info,
            self.device_type == other.device_type,
            self.location == other.location
        ))
    @dclayMethod(fields="list<str>", return_="dict")
    def _to_dict(self, fields):
        return {field: self.__getattribute__(field) for field in fields}
    @dclayMethod(return_="dict")
    def to_dict(self):
        fields = [
            "sensor_type",
            "actuator_type",
            "communication_info",
            "device_type",
            "location"
        ]
        return self._to_dict(fields)
    pass
# End of class definition
